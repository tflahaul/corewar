Chaque joueur est chargé à partir d'un point différent sur l'arène.
A chaque joueur on attribut un processus. En gros c'est une structure avec
des registres et d'autres trucs (carry, id du joueur propriétaire, utile
pour savoir qui est en vie quand un 'live' s'exécute) mais surtout un PC
qui a pour role de stocker l'addresse de l'instruction à lire et exécuter
en mémoire.

Donc au début d'une partie à 2 joueurs on a 2 processus avec des PC
différents puisque les joueurs ont été chargés à des endroits différents.
La valeur dans leurs PC correspond à l'addresse de la première instruction
de leur programme.

Après chaque instruction exécutée, le PC change pour passer à l'instruction
suivante en mémoire (PC = PC + instruction_length) ou à l'addresse passée
en paramètre à l'instruction zjmp (si on exécute zjmp).

Donc si on suit la logique, il va arriver un moment où le processus aura
fini de lire et exécuter son programme et lira des octets vides en
mémoire (ou pire, le programme de l'adversaire :o ). C'est vraiment ce qui
arrive, on a pas d'instruction `kill` ou `halt` pour tuer un processus ou
lui dire de s'arreter. C'est pour cette raison que souvent, la derniere
instruction d'un champion est un jump vers son début.

Un processus peut aussi se dupliquer (on ajoute un nouveau maillon à la
liste), et comme chaque processus a un PC qui lui est propre, on peut très
bien avoir deux processus sur la même instruction. Du coup ouais il peut y
avoir beaucoup plus de processus qu'il n'y a de mémoire dans l'arène.

On sait donc qu'un joueur X est en vie quand l'instruction 'live' est exécutée
par un processus qui a dans son registre r1 le numéro X (l'id du joueur
propriétaire est toujours stocké dans le registre r1). Encore une fois à
partir de là on peut imaginer des stratégies comme: Le processus du joueur A
écrit en mémoire de mettre dans le registre r1 le contenu de son registre r1.
Comme ça si un processus du joueur B exécute cette instruction, son id devient
celui de l'adversaire et on peut dire que le processus est 'piraté'. Tout
ce qu'il fera par la suite sera reporté comme étant du joueur A.
Pas trop de rapport avec les mécanismes de la VM mais je pense que ça peut
t'aider à comprendre la logique d'une partie.

Un processus peut seulement disparaitre s'il n'a pas fait de 'live' dans un
certain nombre de cycles. C'est pour ça qu'on a une variable live dans la
structure des processus, qu'on peut utiliser comme un boolean ou un compteur
de live.
En fait la VM c'est juste une zone de mémoire et une liste de processus un
peu vide au départ, puis une boucle pour parcourir la liste et exécuter les
instructions des PC de chaque processus. Tout ça dans une plus grosse boucle
accompagnée d'un if pour vérifier que les processus soient bien en vie après
CYCLE_TO_DIE cycles, sinon ils sont pop de la liste.

Ok c'est un peu plus compliqué que ça en fait parceque les instructions elles
meme durent plusieurs cycles, en gros si un processus doit faire un fork
(se dupliquer), il doit d'abord attendre 800 cycles, immobile (impossible
pour lui de continuer à lire d'autres instructions). C'est assez handicapant
pour le joueur, parceque le processus peut mourrir avant d'avoir fait son fork.

Au final on a juste une liste chainée, une zone mémoire, des fonctions qui
peuvent modifier les deux, et un bon cocktail de if et de while.
Ce qui serait intéressant pour moi là maintenant ce serait de trouver un
moyen élégant et rapide de décoder les instructions ou faire un champion
VRAIMENT malin, meme si une fois dans l'arene j'ai l'impression que c'est
toujours un peu la lotterie...
